async function saveMeta() {
            const saveButton = event.target;
            const originalText = saveButton.innerHTML;
            saveButton.innerHTML = '<span class="loading"></span> Salvando...';
            saveButton.disabled = true;

            try {
                const id = document.getElementById("metaId").value;
                const titulo = document.getElementById("metaTitulo").value;
                const objetivo = document.getElementById("metaObjetivo").value;
                const programa = document.getElementById("metaPrograma").value;
                
                // Coleta indicadores
                const indicadores = [];
                for (let i = 0; i < 5; i++) {
                    const indicadorElement = document.getElementById(`indicador${i}`);
                    if (indicadorElement && indicadorElement.value.trim()) {
                        indicadores.push(indicadorElement.value.trim());
                    }
                }

                // NOVA: Valida√ß√£o robusta antes de salvar
                const metaData = {
                    title: titulo,
                    objetivo: objetivo,
                    program: programa,
                    indicadores: indicadores
                };

                const validationErrors = DataValidator.validate(metaData, 'meta');
                if (validationErrors.length > 0) {
                    NotificationManager.showValidationErrors(validationErrors);
                    return;
                }

                //        // ========================================
        // VARI√ÅVEIS GLOBAIS
        // ========================================
        let currentUser = null;
        let currentTab = 'dashboard';
        let currentFilter = 'all';
        let isLoading = false;
        
        // Charts
        let acoesPorProgramaChart = null;
        let followupStatusChart = null;

        // Data Arrays (agora carregados do backend)
        let actions = [];
        let followUps = [];
        let tasks = [];
        let metas = [];
        let cronograma = [];
        let inventario = [];
        let activityLog = [];

        // ========================================
        // SISTEMA DE CACHE INTELIGENTE
        // ========================================
        class CacheManager {
            static cache = new Map();
            static TTL = 300000; // 5 minutos
            
            static get(key) {
                const item = this.cache.get(key);
                if (item && Date.now() - item.timestamp < this.TTL) {
                    return item.data;
                }
                this.cache.delete(key);
                return null;
            }
            
            static set(key, data) {
                this.cache.set(key, {
                    data,
                    timestamp: Date.now()
                });
            }
            
            static clear() {
                this.cache.clear();
                console.log('üóëÔ∏è Cache limpo');
            }
            
            static getStats() {
                return {
                    entries: this.cache.size,
                    memory: JSON.stringify([...this.cache.entries()]).length
                };
            }
        }

        // ========================================
        // SISTEMA DE VALIDA√á√ÉO ROBUSTA
        // ========================================
        class DataValidator {
            static schemas = {
                meta: {
                    title: { required: true, minLength: 3, maxLength: 100 },
                    objetivo: { required: true, minLength: 10 },
                    program: { required: true, enum: programs.map(p => p.name) },
                    indicadores: { type: 'array', maxItems: 5 }
                },
                action: {
                    titulo: { required: true, minLength: 3, maxLength: 100 },
                    programa: { required: true, enum: programs.map(p => p.name) },
                    responsavel: { required: true, minLength: 2 },
                    status: { required: true, enum: ['pending', 'in_progress', 'completed'] }
                },
                followup: {
                    mensagem: { required: true, minLength: 10 },
                    prioridade: { required: true, enum: ['baixa', 'media', 'alta', 'urgente'] }
                },
                task: {
                    titulo: { required: true, minLength: 3, maxLength: 100 },
                    responsavel: { required: true, minLength: 2 }
                }
            };
            
            static validate(data, schema) {
                const errors = [];
                const rules = this.schemas[schema];
                
                if (!rules) {
                    return [`Schema '${schema}' n√£o encontrado`];
                }
                
                for (const [field, rule] of Object.entries(rules)) {
                    const value = data[field];
                    
                    if (rule.required && (!value || value.toString().trim() === '')) {
                        errors.push(`${field} √© obrigat√≥rio`);
                        continue;
                    }
                    
                    if (value && rule.minLength && value.length < rule.minLength) {
                        errors.push(`${field} deve ter pelo menos ${rule.minLength} caracteres`);
                    }
                    
                    if (value && rule.maxLength && value.length > rule.maxLength) {
                        errors.push(`${field} deve ter no m√°ximo ${rule.maxLength} caracteres`);
                    }
                    
                    if (value && rule.enum && !rule.enum.includes(value)) {
                        errors.push(`${field} deve ser um dos valores: ${rule.enum.join(', ')}`);
                    }
                    
                    if (value && rule.type === 'array' && rule.maxItems && value.length > rule.maxItems) {
                        errors.push(`${field} deve ter no m√°ximo ${rule.maxItems} itens`);
                    }
                }
                
                return errors;
            }
        }

        // ========================================
        // SISTEMA DE NOTIFICA√á√ïES AVAN√áADAS
        // ========================================
        class NotificationManager {
            static priorities = {
                URGENT: { color: 'red', timeout: 10000, icon: 'üö®' },
                HIGH: { color: 'orange', timeout: 7000, icon: '‚ö†Ô∏è' },
                NORMAL: { color: 'blue', timeout: 5000, icon: '‚ÑπÔ∏è' },
                SUCCESS: { color: 'green', timeout: 4000, icon: '‚úÖ' }
            };
            
            static notify(message, priority = 'NORMAL', actions = null) {
                const config = this.priorities[priority];
                
                if (actions && actions.length > 0) {
                    this.createActionableNotification(message, config, actions);
                } else {
                    this.createSimpleNotification(message, config);
                }
            }
            
            static createSimpleNotification(message, config) {
                showToast(`${config.icon} ${message}`, config.color);
            }
            
            static createActionableNotification(message, config, actions) {
                const toast = document.getElementById("toast");
                
                toast.innerHTML = `
                    <div class="flex items-center space-x-3">
                        <div class="text-${config.color}-600" style="font-size: 20px;">${config.icon}</div>
                        <div class="flex-1">
                            <span class="text-gray-900">${message}</span>
                        </div>
                        <div class="flex space-x-2">
                            ${actions.map(action => 
                                `<button onclick="${action.callback}" class="text-${config.color}-600 hover:text-${config.color}-800 text-sm font-medium px-2 py-1 rounded bg-${config.color}-50">
                                    ${action.label}
                                </button>`
                            ).join('')}
                            <button onclick="hideToast()" class="text-gray-400 hover:text-gray-600">‚úñÔ∏è</button>
                        </div>
                    </div>
                `;
                
                toast.classList.add("show");
                setTimeout(() => hideToast(), config.timeout);
            }
            
            static showValidationErrors(errors) {
                const errorList = errors.map(error => `‚Ä¢ ${error}`).join('<br>');
                this.notify(`Erro de valida√ß√£o:<br>${errorList}`, 'HIGH');
            }
        }

        // ========================================
        // SISTEMA DE AUDITORIA E LOGS
        // ========================================
        class AuditManager {
            static async logOperation(operation, entityType, entityId, changes, userId) {
                const auditLog = {
                    id: Date.now(),
                    timestamp: new Date().toISOString(),
                    operation, // CREATE, UPDATE, DELETE
                    entityType, // meta, action, followup, etc.
                    entityId,
                    changes: typeof changes === 'object' ? JSON.stringify(changes) : changes,
                    userId,
                    userAgent: navigator.userAgent.substring(0, 100),
                    url: window.location.href
                };
                
                try {
                    await APIService.request('audit-log', {
                        method: 'POST',
                        body: JSON.stringify(auditLog)
                    });
                } catch (error) {
                    // Fallback para localStorage se backend n√£o dispon√≠vel
                    const logs = JSON.parse(localStorage.getItem('enedes_audit_logs') || '[]');
                    logs.push(auditLog);
                    
                    // Manter apenas os √∫ltimos 1000 logs
                    if (logs.length > 1000) {
                        logs.splice(0, logs.length - 1000);
                    }
                    
                    localStorage.setItem('enedes_audit_logs', JSON.stringify(logs));
                }
            }
            
            static getAuditLogs(limit = 50) {
                return JSON.parse(localStorage.getItem('enedes_audit_logs') || '[]')
                    .slice(-limit)
                    .reverse();
            }
        }

        // ========================================
        // SISTEMA DE BACKUP AUTOM√ÅTICO
        // ========================================
        class BackupManager {
            static async createBackup() {
                const backupData = {
                    timestamp: new Date().toISOString(),
                    version: "2.2-Enhanced",
                    user: currentUser?.name || 'Sistema',
                    data: {
                        metas,
                        actions,
                        followUps,
                        tasks,
                        cronograma,
                        inventario
                    },
                    systemInfo: {
                        endpoints_status: lastEndpointTest?.summary,
                        cache_stats: CacheManager.getStats(),
                        audit_logs_count: AuditManager.getAuditLogs().length
                    }
                };
                
                const backupKey = 'enedes_backup_' + Date.now();
                localStorage.setItem(backupKey, JSON.stringify(backupData));
                
                // Manter apenas os 10 backups mais recentes
                const allBackups = Object.keys(localStorage)
                    .filter(key => key.startsWith('enedes_backup_'))
                    .sort();
                    
                if (allBackups.length > 10) {
                    allBackups.slice(0, -10).forEach(key => localStorage.removeItem(key));
                }
                
                console.log('‚úÖ Backup autom√°tico criado:', backupKey);
                return backupKey;
            }
            
            static getBackups() {
                return Object.keys(localStorage)
                    .filter(key => key.startsWith('enedes_backup_'))
                    .map(key => {
                        try {
                            const backup = JSON.parse(localStorage.getItem(key));
                            return {
                                key,
                                timestamp: backup.timestamp,
                                user: backup.user,
                                size: localStorage.getItem(key).length
                            };
                        } catch {
                            return null;
                        }
                    })
                    .filter(Boolean)
                    .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            }
            
            static async restoreBackup(backupKey) {
                try {
                    const backupData = JSON.parse(localStorage.getItem(backupKey));
                    
                    if (!backupData || !backupData.data) {
                        throw new Error('Backup inv√°lido');
                    }
                    
                    // Restaurar dados
                    metas = backupData.data.metas || [];
                    actions = backupData.data.actions || [];
                    followUps = backupData.data.followUps || [];
                    tasks = backupData.data.tasks || [];
                    cronograma = backupData.data.cronograma || [];
                    inventario = backupData.data.inventario || [];
                    
                    updateAllData();
                    
                    NotificationManager.notify(
                        `Backup restaurado com sucesso! Data: ${new Date(backupData.timestamp).toLocaleString()}`,
                        'SUCCESS'
                    );
                    
                    await AuditManager.logOperation(
                        'RESTORE',
                        'backup',
                        backupKey,
                        `Backup de ${backupData.user}`,
                        currentUser?.name || 'Sistema'
                    );
                    
                } catch (error) {
                    NotificationManager.notify(`Erro ao restaurar backup: ${error.message}`, 'URGENT');
                }
            }
        }

        // ========================================
        // SISTEMA DE M√âTRICAS AVAN√áADAS
        // ========================================
        class MetricsManager {
            static calculateAdvancedMetrics() {
                const now = new Date();
                const today = now.toDateString();
                const thisWeek = this.getWeekRange(now);
                const thisMonth = this.getMonthRange(now);
                
                return {
                    productivity: {
                        tasksCompletedToday: tasks.filter(t => 
                            t.status === 'completed' && 
                            t.updated_at && new Date(t.updated_at).toDateString() === today
                        ).length,
                        
                        actionsCompletedThisWeek: actions.filter(a =>
                            a.status === 'completed' &&
                            a.updated_at && this.isInRange(new Date(a.updated_at), thisWeek)
                        ).length,
                        
                        overdueTasks: tasks.filter(t => 
                            t.prazo && new Date(t.prazo) < now && t.status !== 'completed'
                        ).length,
                        
                        overdueActions: actions.filter(a =>
                            a.prazo && new Date(a.prazo) < now && a.status !== 'completed'
                        ).length,
                        
                        avgCompletionTime: this.calculateAvgCompletionTime()
                    },
                    
                    programs: programs.map(program => {
                        const programActions = actions.filter(a => a.programa === program.name);
                        const programTasks = tasks.filter(t => {
                            const followUp = followUps.find(f => f.id == t.followup_id);
                            const targetItem = followUp ? 
                                (followUp.type === "action" ? 
                                    actions.find(a => a.id == followUp.target_id) : 
                                    metas.find(m => m.id == followUp.target_id)) : null;
                            return targetItem && targetItem.programa === program.name;
                        });
                        
                        return {
                            name: program.name,
                            totalActions: programActions.length,
                            completedActions: programActions.filter(a => a.status === 'completed').length,
                            totalTasks: programTasks.length,
                            completedTasks: programTasks.filter(t => t.status === 'completed').length,
                            completionRate: programActions.length > 0 ? 
                                Math.round((programActions.filter(a => a.status === 'completed').length / programActions.length) * 100) : 0
                        };
                    }),
                    
                    trends: {
                        weeklyProgress: this.getWeeklyProgressTrend(),
                        monthlyCompletion: this.getMonthlyCompletionRate(),
                        bottlenecks: this.identifyBottlenecks()
                    }
                };
            }
            
            static getWeekRange(date) {
                const startOfWeek = new Date(date);
                startOfWeek.setDate(date.getDate() - date.getDay());
                const endOfWeek = new Date(startOfWeek);
                endOfWeek.setDate(startOfWeek.getDate() + 6);
                return { start: startOfWeek, end: endOfWeek };
            }
            
            static getMonthRange(date) {
                const startOfMonth = new Date(date.getFullYear(), date.getMonth(), 1);
                const endOfMonth = new Date(date.getFullYear(), date.getMonth() + 1, 0);
                return { start: startOfMonth, end: endOfMonth };
            }
            
            static isInRange(date, range) {
                return date >= range.start && date <= range.end;
            }
            
            static calculateAvgCompletionTime() {
                const completedTasks = tasks.filter(t => t.status === 'completed' && t.created_at && t.updated_at);
                
                if (completedTasks.length === 0) return 0;
                
                const totalTime = completedTasks.reduce((sum, task) => {
                    const created = new Date(task.created_at);
                    const completed = new Date(task.updated_at);
                    return sum + (completed - created);
                }, 0);
                
                return Math.round(totalTime / completedTasks.length / (1000 * 60 * 60 * 24)); // dias
            }
            
            static getWeeklyProgressTrend() {
                const weeks = [];
                const now = new Date();
                
                for (let i = 3; i >= 0; i--) {
                    const weekStart = new Date(now);
                    weekStart.setDate(now.getDate() - (now.getDay() + (i * 7)));
                    const weekEnd = new Date(weekStart);
                    weekEnd.setDate(weekStart.getDate() + 6);
                    
                    const weekActions = actions.filter(a => 
                        a.updated_at && this.isInRange(new Date(a.updated_at), {start: weekStart, end: weekEnd})
                    );
                    
                    weeks.push({
                        week: `Sem ${4-i}`,
                        completed: weekActions.filter(a => a.status === 'completed').length,
                        total: weekActions.length
                    });
                }
                
                return weeks;
            }
            
            static getMonthlyCompletionRate() {
                const thisMonth = this.getMonthRange(new Date());
                const monthlyActions = actions.filter(a => 
                    a.created_at && this.isInRange(new Date(a.created_at), thisMonth)
                );
                
                return monthlyActions.length > 0 ? 
                    Math.round((monthlyActions.filter(a => a.status === 'completed').length / monthlyActions.length) * 100) : 0;
            }
            
            static identifyBottlenecks() {
                const bottlenecks = [];
                
                // A√ß√µes pendentes h√° mais de 7 dias
                const staleActions = actions.filter(a => {
                    const daysSinceCreated = (Date.now() - new Date(a.created_at || Date.now())) / (1000 * 60 * 60 * 24);
                    return a.status === 'pending' && daysSinceCreated > 7;
                });
                
                if (staleActions.length > 0) {
                    bottlenecks.push({
                        type: 'stale_actions',
                        count: staleActions.length,
                        description: `${staleActions.length} a√ß√µes pendentes h√° mais de 7 dias`
                    });
                }
                
                // Follow-ups sem resposta
                const unresponsiveFollowUps = followUps.filter(f => {
                    const daysSinceCreated = (Date.now() - new Date(f.created_at || Date.now())) / (1000 * 60 * 60 * 24);
                    return f.status === 'pending' && daysSinceCreated > 3;
                });
                
                if (unresponsiveFollowUps.length > 0) {
                    bottlenecks.push({
                        type: 'unresponsive_followups',
                        count: unresponsiveFollowUps.length,
                        description: `${unresponsiveFollowUps.length} follow-ups sem resposta h√° mais de 3 dias`
                    });
                }
                
                return bottlenecks;
            }
        }
